var p=(n,e,i)=>new Promise((a,t)=>{var s=r=>{try{l(i.next(r))}catch(u){t(u)}},o=r=>{try{l(i.throw(r))}catch(u){t(u)}},l=r=>r.done?a(r.value):Promise.resolve(r.value).then(s,o);l((i=i.apply(n,e)).next())});import{showToast as h}from"./shared.js";const g=["ABCGintoNord-ExtraBold","ggsans-Bold","ggsans-BoldItalic","ggsans-ExtraBold","ggsans-ExtraBoldItalic","ggsans-Medium","ggsans-MediumItalic","ggsans-Normal","ggsans-NormalItalic","ggsans-Semibold","ggsans-SemiboldItalic","NotoSans-Bold","NotoSans-ExtraBold","NotoSans-Medium","NotoSans-Normal","NotoSans-NormalItalic","NotoSans-Semibold","ggmono-Normal"];function m(n){return/^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}|[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4})$/.test(n)}function f(n,e=null,i=null){const a=n.match(/^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0|1|0?\.\d+|1\.0)\s*\)$/i);if(!a)return!1;const[,t,s,o,l]=a.map(u=>parseFloat(u)),r=t>=0&&t<=255&&s>=0&&s<=255&&o>=0&&o<=255&&l>=0&&l<=1;return!r&&e&&i&&i.push(`The value "${n}" for "${e}" contains invalid RGB values (must be between 0 and 255) or alpha value (must be between 0 and 1).`),r}function y(n){return typeof n=="string"&&(m(n)||f(n)||n==="transparent")}function I(n){return/^(https?:\/\/.*\.(ttf|otf)(\?.*)?)$/.test(n)}function v(n){return/^https?:\/\/(cdn\.discordapp\.com|discordapp\.com)/.test(n)}function c(n,e,i,a){return typeof n[e]!==i||i==="string"&&n[e].trim()===""?(a.push(`"${e}" must be a non-empty ${i}.`),!1):!0}function d(n,e,i){return!n[e]||typeof n[e]!="object"||Array.isArray(n[e])?(i.push(`"${e}" must be an object.`),!1):!0}function E(n,e,i=!1){const a=new Set;return g.forEach(t=>{if(n[t]){const s=n[t];a.add(s),I(s)||e.push(`Invalid URL for font "${t}": "${s}".`),v(s)&&e.push(`Font "${t}" cannot use Discord CDN URL.`)}else{if(t==="ggmono-Normal"&&n["SourceCodePro-Semibold"]){i.push('"SourceCodePro-Semibold" has been replaced by "ggmono-Normal" in recent Discord versions. Consider updating your font pack.');return}e.push(`Missing required font: "${t}".`)}}),a.size===1&&Object.keys(n).length>1?e.push("All fonts cannot use the same URL. Different font styles must point to different files."):a.size<Object.keys(n).length*.5&&i.push("Most font styles use the same file, which can prevent visual differences and cause display inconsistencies. Use distinct files for each style."),a}document.getElementById("validateButton").addEventListener("click",function(){const n=document.getElementById("jsonInput").value,e=document.getElementById("result");e.innerHTML="";const i=n.split(`
`);k(i);try{const a=jsonlint.parse(n),{errors:t,warnings:s,type:o}=C(a,i);if(t.length>0)e.innerHTML='<p style="color: red;">Validation errors:</p><ul>',t.forEach(l=>{e.innerHTML+=`<li>${l}</li>`}),e.innerHTML+="</ul>";else{const l=o==="fontpack"?"Valid font pack!":"Valid theme!";e.innerHTML=`<p class="success">${l}</p>`}s.length>0&&(e.innerHTML+='<p style="color: orange;">Validation warnings:</p><ul>',s.forEach(l=>{e.innerHTML+=`<li>${l}</li>`}),e.innerHTML+="</ul>"),e.scrollIntoView({behavior:"smooth"})}catch(a){const t=a.message.match(/line (\d+)/),s=t?parseInt(t[1]):"unknown",o=a.message||"Unknown syntax error";e.innerHTML=`<p class="error">Syntax error on line ${s}: ${o}</p>`,s!=="unknown"&&N(s-1),e.scrollIntoView({behavior:"smooth"})}});function k(n){const e=document.getElementById("lineNumbers");e.innerHTML="",n.forEach((i,a)=>{const t=document.createElement("div");t.textContent=a+1,t.classList.add("line-number"),e.appendChild(t)})}function N(n){const e=document.getElementById("lineNumbers").children;e[n]&&e[n].classList.add("highlight")}function C(n,e){const i=[],a=[];let t="";const s=!!n.main,o=!!n.semanticColors||!!n.rawColors;return!s&&!o?(i.push('Invalid JSON: must contain either "main" for font packs or "semanticColors"/"rawColors" for themes.'),{errors:i,warnings:a,type:"unknown"}):s&&o?(i.push("Invalid JSON: cannot contain both font pack and theme properties."),{errors:i,warnings:a,type:"unknown"}):(t=s?"fontpack":"theme",s?$(n,i,a):L(n,i,a),{errors:i,warnings:a,type:t})}function $(n,e,i){if(c(n,"name","string",e),c(n,"previewText","string",e),c(n,"spec","number",e),n.spec!==1&&e.push('"spec" must be equal to 1.'),!n.main||typeof n.main!="object"){e.push('"main" must be an object containing font definitions.');return}const a=E(n.main,e,i);return Object.keys(n.main).forEach(t=>{!g.includes(t)&&t!=="SourceCodePro-Semibold"&&i.push(`Unknown font "${t}" found in "main".`)}),{errors:e,warnings:i}}function L(n,e,i){var a;if(c(n,"name","string",e),c(n,"description","string",e),n.semanticColors)if(d(n,"semanticColors",e))for(const t in n.semanticColors)Array.isArray(n.semanticColors[t])?n.semanticColors[t].forEach(s=>{if(!y(s)){e.push(`The value "${s}" for "${t}" is not a valid color code.`);return}f(s,t,e)}):e.push(`The key "${t}" in "semanticColors" must be an array.`);else return;if(n.rawColors)if(d(n,"rawColors",e))for(const[t,s]of Object.entries(n.rawColors))Array.isArray(s)?e.push(`The value for "${t}" must be a string, not an array.`):y(s)?f(s,t,e):e.push(`The value "${s}" for "${t}" is not a valid color code.`);else return;if(Array.isArray(n.authors)?n.authors.forEach((t,s)=>{typeof t.name!="string"&&e.push(`The author at index ${s} must have a valid name.`)}):e.push('"authors" must be an array.'),n.spec===void 0?e.push('"spec" is missing.'):(typeof n.spec!="number"||n.spec!==2)&&e.push('"spec" must be equal to 2.'),n.background)if(d(n,"background",e)){if(n.background.url){const t=n.background.url;v(t)?e.push('"background" cannot be a Discord CDN URL.'):/\.(jpg|jpeg|png|gif)(\?.*)?$/i.test(t)||i.push(`The URL "${t}" may not be a valid image URL.`)}["blur","alpha"].forEach(t=>{n.background[t]!==void 0&&(typeof n.background[t]!="number"?e.push(`"${t}" in "background" must be a number.`):(n.background[t]<0||n.background[t]>1)&&e.push(`"${t}" in "background" must be between 0 and 1.`))})}else return;if(n.fonts)if(d(n,"fonts",e)){const t=E(n.fonts,e,i,!0)}else return;if(n.plus&&(n.plus.version!==0&&e.push('"plus.version" must be 0.'),n.plus.customOverlays&&n.plus.iconpack&&i.push('"customOverlays" is incompatible with "iconpack".'),(a=n.plus)!=null&&a.icons)){if(d(n.plus,"icons",e))for(const[t,s]of Object.entries(n.plus.icons))Array.isArray(s)?s.forEach(o=>{m(o)||e.push(`Each color in "${t}" must be a valid HEX color string.`)}):typeof s=="string"&&!m(s)?e.push(`The value of "${t}" must be a valid HEX color string.`):typeof s!="string"&&!Array.isArray(s)&&e.push(`The value of "${t}" in "plus.icons" must be a string or an array of strings.`);else return;n.plus.mentionLineColor&&!m(n.plus.mentionLineColor)&&e.push('"mentionLineColor" must be a valid HEX color string.')}return{errors:e,warnings:i}}document.getElementById("jsonInput").addEventListener("scroll",function(){const n=document.getElementById("lineNumbers");n.scrollTop=this.scrollTop}),document.getElementById("formatButton").addEventListener("click",function(){const n=document.getElementById("jsonInput").value;try{const e=JSON.parse(n),i=JSON.stringify(e,null,4);document.getElementById("jsonInput").value=i}catch(e){document.getElementById("result").innerHTML='<p style="color: red;">Syntax error in JSON, unable to format.</p>'}}),document.getElementById("copyButton").addEventListener("click",function(){return p(this,null,function*(){const n=document.getElementById("jsonInput");try{yield navigator.clipboard.writeText(n.value),h('<span class="material-symbols-rounded" style="color: #4CAF50;">check</span><span>Copied to clipboard!</span>')}catch(e){console.error("Copy error:",e),h('<span class="material-symbols-rounded" style="color: #fa4343;">error</span><span>Failed to copy</span>')}})}),document.getElementById("clearButton").addEventListener("click",function(){document.getElementById("jsonInput").value="",document.getElementById("result").innerHTML=""});
